<?php
# Co-authors

$authors = 
array(
      "ayani" =>
      array("href" => "http://web.it.kth.se/~rassul/",
	    "name" => "Rassul Ayani"),

      "carlsson" =>
      array("href" => "http://www.sics.se/~matsc/",
	    "name" => "Mats Carlsson"),

      "castaneda" =>
      array("href" => "http://www.sics.se/~rcas/",
            "bibtex" => "Castañeda Lozano, Roberto",
	    "name" => "Roberto Castañeda Lozano"),

      "chu" =>
      array("name" => "Geoffrey Chu"),

      "delgado" =>
      array("href" => "http://www.itu.dk/people/alde/",
            "name" => "Alberto Delgado"),
      "duchier" =>
      array("href" => "http://www.univ-orleans.fr/lifo/Members/duchier/",
            "name" => "Denys Duchier"),
      "drejhammar" =>
      array("href" => "http://www.sics.se/~frej/",
            "name" => "Frej Drejhammar"),

      "flener" =>
      array("href" => "http://user.it.uu.se/~pierref/",
	    "name" => "Pierre Flener"),

      "frimodig" =>
      array("href" => "https://www.kth.se/profile/sarhal",
	    "name" => "Sara Frimodig"),

      "fruhwirth" =>
      array("href" => "http://www.informatik.uni-ulm.de/pm/mitarbeiter/fruehwirth/",
	    "name" => "Thom Frühwirth"),

      "haridi" =>
      array("href" => "http://www.sics.se/~seif/",
	    "name" => "Seif Haridi"),
      "havelka" =>
      array("name" => "Dragan Havelka"),
      "henz" =>
      array("href" => "http://www.comp.nus.edu.sg/~henz/",
            "name" => "Martin Henz"),

      "ingmar" =>
      array("href" => "https://www.linkedin.com/in/linnea-ingmar-a4620bba/",
            "name" => "Linnea Ingmar"),

      "jensen" =>
      array("href" => "http://www.itu.dk/people/rmj/",
            "name" => "Rune Møller Jensen",
            "bibtex" => "Rune {Møller Jensen}"),

      "kamrani" =>
      array("name" => "Farzad Kamrani"),

      "kornstaedt" =>
      array("name" => "Leif Kornstaedt"),

      "lagerkvist" =>
      array("href" => "http://web.it.kth.se/~zayenz/",
            "name" => "Mikael Z. Lagerkvist"),

      "mehl" =>
      array("name" => "Michael Mehl"),
      "michel" =>
      array("href" => "http://www.engr.uconn.edu/~ldm/",
	    "name" => "Laurent Michel"),

      "reischuk" => 
      array("href" => "http://www.infsec.cs.uni-sb.de/~reischuk/",
	    "name" => "Raphael M. Reischuk"),

      "scheidhr" =>
      array("name" => "Ralf Scheidhauer"),
      "schulte" => 
      array("href" => "https://chschulte.github.io/",
	    "name" => "Christian Schulte"),
      "smolka" =>
      array("href" => "http://www.ps.uni-sb.de/~smolka/",
	    "name" => "Gert Smolka"),
      "stuckey" =>
      array("href" => "http://www.cs.mu.oz.au/~pjs/",
	    "name" => "Peter J. Stuckey"),

      "tack" =>
      array("href" => "http://www.csse.monash.edu.au/~guidot/",
	    "name" => "Guido Tack"),
      "brand" =>
      array("href" => "http://www.sics.se/~perbrand",
	    "name" => "Per Brand"),

      "vanroy" =>
      array("href" => "http://www.info.ucl.ac.be/people/cvvanroy.html",
	    "name" => "Peter Van Roy",
            "bibtex" => "Peter {Van Roy}"),

      "vanhentenryck" =>
      array("href" => "http://nicta.com.au/people/pvanhentenryck",
	    "name" => "Pascal Van Hentenryck",
            "bibtex" => "Pascal {Van Hentenryck}"),

      "wahlberg" =>
      array("name" => "Lars Wahlberg"),

      "wuertz" =>
      array("name" => "Jörg Würtz"),

      "younas" =>
      array("name" => "Irfan Younas"),

      "loth" =>
      array("name" => "Manuel Loth",
            "href" => "https://sites.google.com/site/lothmanuel/"),

      "sebag" =>
      array("name" => "Michèle Sebag",
            "href" => "http://www.lri.fr/~sebag/"),
    
      "hamadi" =>
      array("name" => "Youssef Hamadi",
            "href" => "http://research.microsoft.com/en-us/people/youssefh/"),

      "schoenauer" =>
      array("name" => "Marc Schoenauer",
            "href" => "http://www.lri.fr/~marc/"),

      "ghb" =>
      array("name" => "Gabriel Hjort Blindell",
            "bibtex" => "Hjort Blindell, Gabriel",
            "href" => "http://web.ict.kth.se/~ghb/"),

      "lee" =>
      array("name" => "Jimmy Ho Man Lee",
            "href" => "http://www.cse.cuhk.edu.hk/~jlee/"),

      "zhu" =>
      array("name" => "Zichen Zhu"),

      "scott" =>
      array("name" => "Joseph D. Scott",
            "bibtex" => "Scott, Joseph D."),
 
      "pearson" =>
      array("name" => "Justin Pearson",
            "href" => "http://user.it.uu.se/~justin/"),
 
      "corcoran" =>
      array("name" => "Diarmuid Corcoran",
            "href" => "https://www.kth.se/profile/diarmuid/"),

      "andimeh" =>
      array("name" => "Logman Andimeh"),

      "ermedahl" =>
      array("name" => "Andreas Ermedahl"),

      "kreuger" =>
      array("name" => "Per Kreuger",
            "href" => "https://www.sics.se/people/per-kreuger")
	);


$bibeditors = array("Peter van Beek" => "Peter {van Beek}",
                    "Peter Van Roy"  => "Peter {Van Roy}",
                    "schulte" => "Christian Schulte");

# Publisher and series info

$MIT  = "The MIT Press";
$ACM  = "ACM Press";
$LNCS = "Lecture Notes in Computer Science";
$LNAI = "Lecture Notes in Artificial Intelligence";
$SPR  = "Springer-Verlag";
$TOPLAS = "Transactions on Programming Languages and Systems";
$TECS = "Transactions on Embedded Computing Systems";
$LCTES = "Languages, Compilers, Tools and Theory for Embedded Systems";
   
# Copyright info
$LNCS_COPY = "Copyright Springer-Verlag, the original publication is available at <a href=\"http://www.springerlink.com/\">www.springerlink.com</a>";

function ACM_COPY($year) {
  return "Copyright ACM, $year. This is the author's version of the work. It is posted here by permission of ACM for your personal use. Not for redistribution. The definite version was published as described above.";
}

$IEEE_COPY = "Copyright &copy; IEEE. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.";

$AAAI_COPY = "Copyright &copy by <a href=\"http://www.aaai.org\">American Association for Artificial Intelligence</a>.";

# The papers
      
$papers =
array(
      "FrimodigSchulte:CPAIOR:2019" =>
      array("type" =>        "conference",
            "editor" =>      array("Louis-Martin Rousseau","Kostas Stergiou"),
	    "booktitle" =>   "Sixteenth International Conference on the Integration of Constraint Programming, Artificial Intelligence, and Operations Research",
	    "year" =>        2019,
	    "month" =>       "JUN",
	    "address" =>     "Thessaloniki, Greece",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "copyright" =>   $LNCS_COPY,
	    "author" =>      array("frimodig","schulte"),
            "affiliation" => "KTH",
	    "title" =>       "Radiation Therapy Patient Scheduling",
            "selected" => 1,
            "toappear" => 1,
            "note" => "Extended Abstract",
	    "abstract" =>    <<<EOA
<p>    
Radiation therapy (RT), chemotherapy and surgery are the most commonly used cancer therapies worldwide. RT treatments are generally divided into a number of occasions delivered once a day that together sum up to the planned radiation dose. The length of the daily sessions vary between patients. In this work, we use combinatorial optimization to  schedule RT patients taking future patient arrivals into account. 
</p>
<p>
In this work, we develop two different models; a MIP model and a Constraint Programming (CP) model. We aim to find the optimal treatment allocation for patients in a 100 day planning horizon, while taking expected future patient arrivals into account. It is, to the best of our knowledge, the first time the radiotherapy patient scheduling problem is modeled using CP, and also the first time expected future patient arrivals are included in a MIP model. 
</p>
EOA
	    ),

      "IngmarSchulte:CP:2018" =>
      array("type" =>        "conference",
            "editor" =>      array("John Hooker"),
	    "booktitle" =>   "Twentyforth International Conference on Principles and Practice of Constraint Programming",
	    "year" =>        2018,
	    "month" =>       "AUG",
	    "address" =>     "Lille, France",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "copyright" =>   $LNCS_COPY,
            "pages" =>       array(210,218),
	    "author" =>      array("ingmar","schulte"),
            "affiliation" => "KTH",
	    "title" =>       "Making Compact-Table Compact",
	    "DOI" =>         "10.1007/978-3-319-98334-9_14",
            "volume" =>      11008, 
            "selected" => 1,
	    "abstract" =>    <<<EOA
<p>    
  The compact-table propagator for table constraints appears to
  be a strong candidate for inclusion into any constraint solver
  due to its efficiency and simplicity. However, successful
  integration into a constraint solver based on <em>copying</em>
  rather than trailing is not obvious: while the underlying
  bit-set data structure is <em>sparse</em> for efficiency it is not
  <em>compact</em> for memory, which is essential for a copying
  solver.
</p>
<p>
  The paper introduces techniques to make compact-table an
  excellent fit for a copying solver. The key is to make sparse
  bit-sets <em>dynamically compact</em> (only their essential parts
  occupy memory and their implementation is dynamically adapted
  during search) and tables <em>shared</em> (their read-only parts
  are shared among copies).
Dynamically compact bit-sets reduce peak memory by 7.2% and runtime by 13.6% on average and by up to 66.3% and 33.2%. Shared tables even further reduce runtime and memory usage. The reduction in runtime exceeds the reduction in memory and a cache analysis indicates that our techniques might also be beneficial for trailing solvers. The proposed implementation has replaced Gecode's original implementations as it runs on average almost an order of magnitude faster while using half the memory.
</p>
EOA
	    ),

      "CastanedaCarlssonEa:CCoR:2018" =>
      array("type" =>        "corr",
            "title" => "Combinatorial Register Allocation and Instruction Scheduling",
	    "year" =>     2018,
            "month" => "APR",
            "selected" => 1,
            "link" =>        "http://arxiv.org/abs/1804.02452",
	    "author" =>    array("castaneda","carlsson","ghb","schulte"),
	    "abstract" => <<<EOA
<p>	     
This paper introduces a combinatorial optimization approach to register allocation and instruction scheduling,
two central compiler problems. Combinatorial optimization has the potential to solve these problems optimally
and to exploit processor-specific features readily. Our approach is the first to leverage this potential in practice:
it captures the complete set of program transformations used in state-of-the-art compilers, scales to mediumsized
functions of up to 1000 instructions, and generates executable code. This level of practicality is reached
by using constraint programming, a particularly suitable combinatorial optimization technique. Unison, the
implementation of our approach, is open source, used in industry, and integrated with the LLVM toolchain.
</p>
<p>
An extensive evaluation confirms that Unison generates better code than LLVM while scaling to mediumsized
functions. The evaluation uses systematically selected benchmarks from MediaBench and SPEC CPU2006
and different processor architectures (Hexagon, ARM, MIPS). Mean estimated speedup ranges from 1% to 9.3%
and mean code size reduction ranges from 0.8% to 3.9% for the different architectures. Executing the generated
code on Hexagon confirms that the estimated speedup indeed results in actual speedup. Given a fixed time
limit, Unison solves optimally functions of up to 647 instructions, improves functions of up to 874 instructions,
and achieves more than 85% of the potentially optimal speed for 90% of the functions on Hexagon.
</p>
<p>
The results show that our combinatorial approach can be used in practice to trade compilation time for code
quality beyond the usual compiler optimization levels, fully exploit processor-specific features, and identify
improvement opportunities in heuristic algorithms.
</p>
EOA
	    ),
      
      "CastanedaSchulte:CSUR:2018" =>
      array("type" =>        "article",
            "journal" =>     "Computing Surveys",
	    "year" =>        2018,
	    "publisher" =>   $ACM,
	    "author" =>      array("castaneda","schulte"),
            "affiliation" => "KTH",
            "toappear"        => 1,
            "selected" => 1,
	    "title" =>       "Survey on Combinatorial Register Allocation and Instruction Scheduling",
	    "abstract" =>    <<<EOA
<p>    
  Register allocation (mapping variables to processor registers or
  memory) and instruction scheduling (reordering instructions to
  increase instruction-level parallelism) are essential tasks for
  generating efficient assembly code in a compiler.
  In the last three decades, combinatorial optimization has emerged as
  an alternative to traditional, heuristic algorithms for these two
  tasks.
  Combinatorial optimization approaches can deliver optimal solutions
  according to a model, can precisely capture trade-offs between
  conflicting decisions, and are more flexible at the expense of
  increased compilation time.
</p>
<p>
  This paper provides an exhaustive literature review and a
  classification of combinatorial optimization approaches to register
  allocation and instruction scheduling, with a focus on the
  techniques that are most applied in this context: integer
  programming, constraint programming, partitioned Boolean quadratic
  programming, and enumeration.
  Researchers in compilers and combinatorial optimization can benefit
  from identifying developments, trends, and challenges in the area;
  compiler practitioners may discern opportunities and grasp the
  potential benefit of applying combinatorial optimization.
</p>
EOA
	    ),

#      "LeeSchulteEa:AIJ:2018" =>
#      array("type" =>        "article",
#            "journal" =>     "Artificial Intelligence",
#	    "year" =>        2018,
#	    "publisher" =>   "Elsevier",
#	    "author" =>      array("lee","schulte","zhu"),
#            "affiliation" => "KTH",
#            "toappear"        => 1,
#	    "title" =>       "Increasing Nogoods",
#	    "abstract" =>    <<<EOA
#<p>    
#  Nogoods are widely used in constraint programming to prune
#  infeasible parts of the search space.
#  Quite often, a large number of nogoods is generated, proliferating the constraint propagation engine with numerous weak propagators.
#We introduce the property of increasing on a sequence of nogoods and prove that nogoods generated in Symmetry Breaking During Search (SBDS) and its variants as well as reduced nld-nogoods extracted
#from restart-based search satisfy the increasing property. We also introduce an efficient approximation to
#nogood minimization such that all shortened reduced nld-nogoods from the same restart are also increasing. A global constraint for a sequence of
#  increasing nogoods, incNGs, is proposed.
#  Reasoning globally with increasing nogoods allows for a more compact data representation and extra pruning.
#  An efficient
#   GAC algorithm of incNGs and also its incremental version are given.
# A lightweight filtering algorithm for incNGs in the context of restart-based search using dynamic event sets (dynamic subscriptions) is further presented. We show formally that the lightweight version enforces GAC on individual
#nogoods while reducing the number of subscribed decisions.
#Extensive experimentation demonstrates how incNGs can increase
#propagation and speed up search compared to existing state-of-the-art techniques.
#</p>
#EOA
#	    ),

      "CorcoranAndimehEa:CNSM:2017" =>
      array("type" =>        "conference",
	    "title" =>       "Data Driven Selection of DRX for Energy Efficient 5G RAN",
	    "booktitle" =>   "International Conference on Network and Service Management",
	    "address" =>     "Tokyo, Japan",
	    "year" =>        2017,
            "month" =>       "NOV",
            "affiliation" => "KTH",
            "copyright" =>   $IEEE_COPY,
	    "author" =>      array("corcoran","andimeh","ermedahl","kreuger","schulte"),
            "pages" =>       array(1,9),
            "selected" => 1,
	    "DOI" =>         "10.23919/CNSM.2017.8255972", 
	    "abstract" =>    <<<EOA
<p>
The number of connected mobile devices is increasing rapidly with more than 10 billion expected by 2022. Their total aggregate energy consumption poses a significant concern to society. The current 3gpp (3rd Generation Partnership Project) LTE/LTE-Advanced standard incorporates an energy saving technique called discontinuous reception (DRX). It is expected that 5G will use an evolved variant of this scheme. In general, the single selection of DRX parameters per device is non trivial. This paper describes how to improve energy efficiency of mobile devices by selecting DRX based on the traffic profile per device. Our particular approach uses a two phase data-driven strategy which tunes the selection of DRX parameters based on a smart fast energy model. The first phase involves the off-line selection of viable DRX combinations for a particular traffic mix. The second phase involves an on-line selection of DRX from this viable list. The method attempts to guarantee that latency is not worse than a chosen threshold. Alternatively, longer battery life for a device can be traded against increased latency. We built a live prototype of the system in our lab in order to verify that the technique works and scales on a real LTE system. We also designed a sophisticated traffic generator based on actual user data traces. Complementary method verification has been made by exhaustive off-line simulations on recorded LTE network data. Finally we managed to show significant device energy saving using our approach, which has the aggregated potential over billions of devices, to make a real contribution to green, energy efficient networks.
</p>
EOA
	    ),

     "HjortBlindellCarlssonEa:TECS:2017" =>
      array("type" =>        "article",
            "selected" => 1,
	    "title" =>       "Complete and Practical Universal Instruction Selection",
	    "journal" =>     $TECS,
	    "publisher" =>   $ACM,
	    "year" =>        2017,
            "month" =>       "OCT",
            "volume" =>      16,
            "issue" =>       "5s",
	    "author" =>      array("ghb","carlsson","castaneda","schulte"),
            "copyright" =>   ACM_COPY("2017"),
            "affiliation" => "KTH",
            "DOI" =>         "10.1145/3126528",
	    "abstract" =>    <<<EOA
<p>    
In code generation, instruction selection chooses processor instructions to implement a program under compilation
where code quality crucially depends on the choice of instructions. Using methods from combinatorial
optimization, this paper proposes an expressive model that integrates global instruction selection with global
code motion. The model introduces (1) handling of memory computations and function calls, (2) a method for
inserting additional jump instructions where necessary, (3) a dependency-based technique to ensure correct
combinations of instructions, (4) value reuse to improve code quality, and (5) an objective function that reduces
compilation time and increases scalability by exploiting bounding techniques. The approach is demonstrated to
be complete and practical, competitive with LLVM, and potentially optimal (w.r.t. the model) for medium-sized
functions. The results show that combinatorial optimization for instruction selection is well-suited to exploit
the potential of modern processors in embedded systems.
</p>
EOA
	    ),
    
      "ScottFlenerEa:CPAIOR:2017" =>
      array("type" =>        "conference",
            "selected" => 1,
            "editor" =>      array("Domenico Salvagnin","Michele Lombardi"),
	    "booktitle" =>   "Fourteenth International Conference on Integration of Artificial Intelligence and Operations Research Techniques in Constraint Programming",
	    "year" =>        2017,
	    "month" =>       "JUN",
	    "address" =>     "Padova, Italy",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "copyright" =>   $LNCS_COPY,
	    "author" =>      array("scott","flener","pearson","schulte"),
            "affiliation" => "KTH",
	    "title" =>       "Design and Implementation of Bounded-Length Sequence Variables",
            "pages" =>       array(51,67),
	    "DOI" =>         "10.1007/978-3-319-59776-8_5",
	    "abstract" =>    <<<EOA
<p>    
We present the design and implementation of bounded-length sequence (BLS) variables for a CP solver. The domain of a BLS variable is represented as the combination of a set of candidate lengths and a sequence of sets of candidate characters. We show how this choice of representation, together with requirements imposed by propagators, affects the implementation of BLS variables for a modern CP copying solver, most importantly the closely related decisions of data structure, domain restriction operations, and propagation events. The resulting implementation outperforms traditional bounded-length string representations for finite-domain solvers, which use a fixed-length array of candidate characters and a padding symbol. The performance improvement on benchmark problems is significant.
</p>
EOA
	    ),

      "LeeSchulteEa:AAAI:2016" =>
      array("type" =>        "conference",
            "selected" => 1,
            "editor" =>      array("Dale Schuurmans","Michael Wellman"),
	    "booktitle" =>   "AAAI Conference on Artificial Intelligence",
	    "year" =>        2016,
	    "month" =>       "FEB",
	    "address" =>     "Phoenix, AZ, USA",
            "pages" =>       array(3426,3433),
	    "publisher" =>   "AAAI Press",
            "copyright" =>   $AAAI_COPY,
	    "author" =>      array("lee","schulte","zhu"),
            "affiliation" => "KTH",
	    "title" =>       "Increasing Nogoods in Restart-Based Search",
	    "abstract" =>    <<<EOA
<p>    
Restarts are an important technique to make search more robust. The benefit of restarts can be considerably enhanced by recording nogoods generated at the end of each search run and propagating them in future runs to avoid repeating erroneous search decisions. This paper is concerned with how to maintain and propagate nogoods recorded from restarts efficiently. It builds on reduced nld-nogoods introduced for restarts and increasing nogoods introduced for symmetry breaking. The paper shows that reduced nld-nogoods extracted from a single restart are in fact increasing, which can thus benefit from the strong propagation power of the incNGs global constraint. We present a lightweight filtering algorithm for incNGs in the context of restart-based search using dynamic event sets (dynamic subscriptions). We show formally that the lightweight version enforces GAC on each nogood while reducing the number of subscribed decisions. The paper also introduces an efficient approximation to nogood minimization such that all shortened reduced nld-nogoods from the same restart are also increasing and can be propagated with the new filtering algorithm. Experimental results confirm that our lightweight filtering algorithm and approximated nogood minimization successfully trade a slight loss in pruning for considerably better efficiency, and hence compare favorably against existing state-of-the-art techniques.
</p>
EOA
	    ),

      "HjortBlindellCastanedaEa:CP:2015" =>
      array("type" =>        "conference",
            "editor" =>      array("Gilles Pesant"),
	    "booktitle" =>   "Twentyfirst International Conference on Principles and Practice of Constraint Programming",
	    "year" =>        2015,
	    "month" =>       "SEP",
	    "address" =>     "Cork, Ireland",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "copyright" =>   $LNCS_COPY,
	    "author" =>      array("ghb","castaneda","carlsson","schulte"),
            "affiliation" => "KTH",
	    "title" =>       "Modeling Universal Instruction Selection",
            "pages" =>       array(609,626),
            "volume" =>      9255,
	    "DOI" =>         "10.1007/978-3-319-23219-5_42",
	    "abstract" =>    <<<EOA
<p>    
Instruction selection implements a program under compilation
by selecting processor instructions and has tremendous impact on
the performance of the code generated by a compiler. This paper introduces
a graph-based <em>universal</em> representation that unifiees data and
control flow for both programs and processor instructions. The representation
is the essential prerequisite for a constraint model for instruction
selection introduced in this paper. The model is demonstrated to be expressive
in that it supports many processor features that are out of reach
of state-of-the-art approaches, such as advanced branching instructions,
multiple register banks, and SIMD instructions. The resulting model can
be solved for small to medium size input programs and sophisticated processor
instructions and is competitive with LLVM in code quality. Model
and representation are significant due to their expressiveness and their
potential to be combined with models for other code generation tasks.
</p>
EOA
	    ),

      "CastanedaSchulte:CCoR:2014" =>
      array("type" =>        "corr",
            "title" => "Survey on Combinatorial Register Allocation and Instruction Scheduling",
	    "year" =>     2014,
            "month" => "SEP",
            "link" =>        "http://arxiv.org/abs/1409.7628",
	    "author" =>    array("castaneda","schulte"),
	    "abstract" => <<<EOA
<p>	     
Register allocation and instruction scheduling are two central compiler back-end problems that are critical for quality. In the last two decades, combinatorial optimization has emerged as an alternative approach to traditional, heuristic algorithms for these problems. Combinatorial approaches are generally slower but more flexible than their heuristic counterparts and have the potential to generate optimal code. This paper surveys existing literature on combinatorial register allocation and instruction scheduling. The survey covers approaches that solve each problem in isolation as well as approaches that integrate both problems. The latter have the potential to generate code that is globally optimal by capturing the trade-off between conflicting register allocation and instruction scheduling decisions.
</p>
EOA
	    ),
      
      "SchulteTack:CP:2014" =>
      array("type" =>        "conference",
            "editor" =>      array("Barry O'Sullivan"),
	    "booktitle" =>   "Twentieth International Conference on Principles and Practice of Constraint Programming",
	    "year" =>        2014,
	    "month" =>       "SEP",
	    "address" =>     "Lyon, France",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "copyright" =>   $LNCS_COPY,
            "title" => "View-based Propagator Derivation",
	    "author" =>    array("schulte","tack"),
            "pages" =>       array(938,942),
            "volume" =>      8656,
	    "DOI" =>         "10.1007/978-3-319-10428-7_71",
	    "abstract" => <<<EOA
<p>	     
  When implementing a propagator for a constraint, one must decide
  about variants: When implementing min, should one also implement
  max?  Should one implement linear equations both with and without
  coefficients?  Constraint variants are ubiquitous: implementing them
  requires considerable effort, but yields better 
  performance.
</p>
<p>
  This abstract shows how to use <em>views</em> to <em>derive</em>
  propagator variants where derived propagators are
  <em>perfect</em> in that they inherit essential properties such
  as correctness and domain and bounds consistency. Techniques
  for systematically deriving propagators are developed, and the
  abstract sketches an implementation architecture for views that is
  independent of the underlying constraint programming system.
  Evaluation of views implemented in Gecode shows that derived
  propagators are efficient and that views often incur no
  overhead. Views have proven essential for implementing Gecode,
  substantially reducing the amount of code that needs to be
  written and maintained.
</p>
EOA
	    ),
      
      "CastanedaCarlssonEa:LCTES:2014" =>
      array("type" =>        "conference",
            "selected" => 1,
            "editor" =>      array("Prasad Kulkarni"),
	    "booktitle" =>   $LCTES,
	    "year" =>        2014,
	    "month" =>       "JUN",
	    "address" =>     "Edinburgh, UK",
	    "publisher" =>   $ACM,
            "pages" =>       array(23,32),
	    "author" =>      array("castaneda","carlsson","ghb","schulte"),
            "copyright" =>   ACM_COPY("2014"),
            "affiliation" => "KTH",
	    "title" =>       "Combinatorial Spill Code Optimization and Ultimate Coalescing",
	    "abstract" =>    <<<EOA
<p>
  This paper presents a novel combinatorial model that integrates
  global register allocation based on ultimate coalescing, spill
  code optimization, register packing, and multiple register
  banks with instruction scheduling (including VLIW). The model
  exploits alternative temporaries that hold the same value as a
  new concept for ultimate coalescing and spill code
  optimization.
</p>
<p>
  The paper presents Unison as a code generator based on the
  model and advanced solving techniques using constraint
  programming. Thorough experiments using MediaBench and a
  processor (Hexagon) that are typical for embedded systems
  demonstrate that Unison: is robust and scalable; generates
  faster code than LLVM (up to 41% with a mean improvement of
  7%); possibly generates optimal code (for 29% of the
  experiments); effortlessly supports different optimization
  criteria (code size on par with LLVM).
</p>
<p>
  Unison is significant as it addresses the same aspects as
  traditional code generation algorithms, yet is based on a
  simple integrated model and robustly can generate optimal code.
</p>
EOA
	    ),

      "Schulte:CP:2013" =>
      array("type" =>        "proceedings",
            "selected" => 1,
	    "editor" =>      array("schulte"),
	    "title" =>       "Principles and Practice of Constraint Programming - CP 2013",
	    "booktitle" =>       "Principles and Practice of Constraint Programming - CP 2013",
	    "link" =>        "http://www.springer.com/computer/theoretical+computer+science/book/978-3-642-40626-3",
	    "year" =>        2013,
	    "month" =>       "SEP",
	    "address" =>     "Uppsala, Sweden",
            "series" =>      $LNCS,
            "volume" =>      8124,
	    "publisher" =>   $SPR,
	    "abstract" =>    <<<EOA
<p>
This book constitutes the refereed conference proceedings of the 19th International Conference on Principles and Practice of Constraint Programming (CP 2013), held in Uppsala, Sweden, in September 2013. 
The 59 revised papers presented together with 5 invited talks were carefully selected from 170 submissions. The scope of the conference is on all aspects of computing with constraints, including: theory, algorithms, environments, languages, models and systems, applications such as decision making, resource allocation, and agreement technologies.
</p>
EOA
	    ),

      "LothSebagEa:CoCoMile:2013" =>
      array("type" =>        "workshop",
            "selected" => 1,
	    "booktitle" =>   "COmbining COnstraint solving with MIning and LEarning",
	    "year" =>        2013,
	    "month" =>       "JUL",
	    "address" =>     "Bellevue, WA, USA",
	    "author" =>      array("loth","sebag","hamadi","schulte","schoenauer"),
            "affiliation" => "KTH",
	    "title" =>       "Bandit-based Search for Constraint Programming",
	    "abstract" =>    <<<EOA
<p>    
Constraint Programming (CP) solvers classically explore the
solution space using tree-search based heuristics. Monte-
Carlo Tree-Search (MCTS) is a tree-search method aimed at
optimal sequential decision making under uncertainty. At the
crossroads of CP and MCTS, this paper presents the Bandit
Search for Constraint Programming (BASCOP) algorithm,
adapting MCTS to the specifics of CP search trees. Formally,
MCTS simultaneously estimates the average node reward,
and uses it to bias the exploration towards the most promising
regions of the tree, borrowing the multi-armed bandit (MAB)
decision rule. The two contributions in BASCOP concern i) a
specific reward function, estimating the relative failure depth
conditionally to a (variable, value) assignment; ii) a new decision
rule, hybridizing the MAB framework and the spirit
of local neighborhood search. Specifically, BASCOP guides
the CP search in the neighborhood of the previous best solution,
by exploiting statistical estimates gathered across multiple
restarts. BASCOP, using Gecode as the underlying constraint
solver, shows significant improvements over the depthfirst
search baseline on some CP benchmark suites. For hard
job-shop scheduling problems, BASCOP matches the results
of state-of-the-art scheduling-specific CP approaches. These
results demonstrate the potential of BASCOP as a generic yet
robust search method for CP.</p>
EOA
	    ),

      "CastanedaCarlssonEa:MSCOPES:2013" =>
      array("type" =>        "workshop",
            "editor" =>      array("Sander Stuijk"),
	    "booktitle" =>   "Sixteenth International Workshop on Software and Compilers for Embedded Systems",
	    "year" =>        2013,
	    "month" =>       "JUN",
	    "address" =>     "St. Goar, Germany",
	    "publisher" =>   $ACM,
            "copyright" =>   ACM_COPY("2013"),
	    "author" =>      array("castaneda","ghb","carlsson","drejhammar","schulte"),
            "pages" =>       array(93,95),
            "affiliation" => "KTH",
	    "title" =>       "Constraint-based Code Generation",
	    "abstract" =>    <<<EOA
<p>    
Compiler back-ends generate assembly code by solving three main tasks:
instruction selection, register allocation and instruction scheduling.
We introduce constraint models and solving techniques for these code generation
tasks and describe how the models can be composed to generate code in unison.
The use of constraint programming, a technique to model and solve combinatorial
problems, makes code generation simple, flexible, robust and potentially
optimal.
</p>
EOA
	    ),

      
      "LothSebagEa:LION:2013" =>
      array("type" =>        "conference",
            "selected" => 1,
            "editor" =>      array("Giuseppe Nicosia","Panos Pardalos"),
	    "booktitle" =>   "Learning and Intelligent OptimizatioN Conference (Lion 7)",
	    "year" =>        2013,
	    "month" =>       "JAN",
	    "address" =>     "Catania, Italy",
	    "author" =>      array("loth","sebag","hamadi","schoenauer","schulte"),
            "affiliation" => "KTH",
	    "title" =>       "Hybridizing Constraint Programming and Monte-Carlo Tree Search: Application to the Job Shop problem",
	    "abstract" =>    <<<EOA
<p>    
Constraint Programming (CP) solvers classically explore the solution 
space using tree search-based heuristics.  
Monte-Carlo Tree-Search (MCTS), a tree search-based method aimed at 
sequential decision making under uncertainty, 
simultaneously estimates the reward associated to the sub-trees, and gradually
biases the exploration toward the most promising sub-trees. 
This paper examines the tight combination of  MCTS and CP 
 on the job shop problem (JSP). The contribution is twofold. Firstly, a reward 
function compliant with a multiple restart policy is proposed. 
Secondly, a biased MCTS node selection rule based on this reward is proposed. 
Its integration within the Gecode constraint 
solver is shown to compete with JSP-specific 
CP approaches on difficult JSP instances.
</p>
EOA
	    ),

      
      "SchulteTack:Constraints:2012" =>
      array("type" =>        "article",
            "selected" => 1,
            "title" => "View-based Propagator Derivation",
	    "year" =>  2013,
            "month" => "JAN",
            "volume" => 18,
            "number" => 1,
            "pages" => array(75,107),
            "journal" => "Constraints",
            "publisher" => $SPR,
            "copyright" => $LNCS_COPY,
            "DOI" => "10.1007/s10601-012-9133-z",
	    "author" =>    array("schulte","tack"),
            "affiliation" => "KTH",
	    "abstract" => <<<EOA
<p>	     
  When implementing a propagator for a constraint, one must
  decide about variants: When implementing min, should one
  also implement max?  Should one implement linear constraints
  both with unit and non-unit coefficients?  Constraint variants
  are ubiquitous: implementing them requires considerable (if not
  prohibitive) effort and decreases maintainability, but will
  deliver better performance than resorting to constraint
  decomposition.
</p>
<p> 
  This paper shows how to use <em>views</em> to <em>derive</em> propagator
  variants, combining the efficiency of dedicated propagator implementations
  with the simplicity and effortlessness of decomposition.
</p>
<p>
  A model for views and derived propagators
  is introduced. Derived propagators are proved to be 
  <em>perfect</em> in that they inherit essential properties such as
  correctness and domain and bounds consistency. Techniques for
  systematically deriving propagators such as transformation,
  generalization, specialization, and type conversion are
  developed. The paper introduces an implementation architecture
  for views that is independent of the underlying constraint
  programming system.  A detailed evaluation of views implemented
  in Gecode shows that derived propagators are efficient and that
  views often incur no overhead. Views have proven essential for implementing 
  Gecode, substantially reducing the amount of code that needs to be written 
  and maintained.
</p>
EOA
	    ),
      
      "CastanedaCarlssonEa:CP:2012" =>
      array("type" =>        "conference",
            "selected" => 1,
            "editor" =>      array("Michela Milano"),
	    "booktitle" =>   "Eighteenth International Conference on Principles and Practice of Constraint Programming",
	    "year" =>        2012,
	    "month" =>       "OCT",
	    "address" =>     "Québec City, Canada",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "copyright" =>   $LNCS_COPY,
	    "author" =>      array("castaneda","carlsson","drejhammar","schulte"),
            "pages" =>       array(750,766),
            "volume" =>      7514,
	    "DOI" =>         "10.1007/978-3-642-33558-7_54",
            "affiliation" => "KTH",
	    "title" =>       "Constraint-based Register Allocation and Instruction Scheduling",
	    "abstract" =>    <<<EOA
<p>    
  This paper introduces a constraint model and solving techniques
  for code generation in a compiler back-end.
  It contributes a new model for global register allocation that
  combines several advanced aspects: multiple register banks
  (subsuming spilling to memory), coalescing, and packing. The
  model is extended to include instruction scheduling and
  bundling.
  The paper introduces a decomposition scheme exploiting the underlying
  program structure and exhibiting robust behavior for
  functions with thousands of instructions.  Evaluation shows
  that code quality is on par with LLVM, a state-of-the-art
  compiler infrastructure.
</p>
<p>
  The paper makes important contributions to the applicability of
  constraint programming as well as compiler construction:
  essential concepts are unified in a high-level model
  that can be solved by readily available modern solvers. This is
  a significant step towards basing code generation entirely on
  a high-level model and by this facilitates the construction of
  correct, simple, flexible, robust, and high-quality code
  generators.
</p>
EOA
	    ),

      "YounasKamraniEa:CISched:2011" =>
      array("type" =>        "conference",
	    "title" =>       "Optimization of Task Assignment to Collaborating Agents",
	    "booktitle" =>   "IEEE Symposium on Computational Intelligence in Scheduling",
	    "address" =>     "Paris, France",
	    "year" =>        2011,
            "month" =>       "APR",
            "DOI" =>         "10.1109/SCIS.2011.5976547",
            "affiliation" => "KTH",
            "pages" =>       array(17,24),
            "copyright" =>   $IEEE_COPY,
	    "author" =>      array("younas","kamrani","schulte","ayani"),
	    "abstract" =>    <<<EOA
<p>
The classic task assignment problem (AP) assigns m
agents to n tasks, where each task is assigned to exactly one agent.
This problem and many of its variations, including the case where
a task is assigned to a group of agents working independently,
have been discussed extensively in the literature. We consider
a specific class of task assignment problems where each task is
assigned to a group of collaborating agents that work as a team.
Thus, changing one of the group members may have a vital
impact on the output of the group. We assume that each agent
has a set of capabilities and each task has certain requirements.
The objective is to assign agents to teams such that the gain is
maximized.
</p>
<p>
We suggest a Genetic Algorithm (GA) for finding a near
optimal solution to this class of task assignment problems. To the
best of our knowledge, this class of APs has not been considered
in the literature, probably due to the difficulty of evaluating the
performance of a team of agents. Recently, we have developed
a formal method for measuring performance of a team which is
used in this paper to formulate the objective function of our GA.
We analyze the quality of the obtained solution by comparing
the result of our GA with (a) the exact solution of some smaller
problems, and (b) with the results of the exact solution of specific
cases that can be obtained by the Hungarian algorithm. We
provide experimental results on efficiency, stability, robustness
and scalability of the solution obtained by our GA.
</p>
EOA
	    ),

      "SchulteTack:TRICS:2010" =>
      array("type" =>        "workshop",
	    "title" =>       "Implementing Efficient Propagation Control",
	    "booktitle" =>   "Proceedings of TRICS: Techniques foR Implementing Constraint programming Systems, a conference workshop of CP 2010",
	    "address" =>     "St Andrews, UK",
	    "year" =>        2010,
            "month" =>       "SEP",
            "affiliation" => "KTH",
	    "author" =>      array("schulte","tack"),
	    "abstract" =>    <<<EOA
<p>
In propagation-based constraint solvers, <em>propagators</em>
implement constraints by removing inconsistent values from
variable domains. To make propagation efficient, modern
constraint solvers employ two mechanisms of propagation control,
<em>event-based</em> and <em>prioritized</em>
propagation. Events, such as a bounds change of a particular
variable, control which propagators need to be scheduled for
re-evaluation. Prioritization controls which of the scheduled
propagators is executed next.
</p>
<p>
While it has been shown that the combination of event-based and
priority-based scheduling is an efficient approach for
propagation control, this is the first publication on the
implementation details of such a system.
</p>
<p>
This paper presents the design of efficient data structures for
propagator priority queues and the event system. The paper
introduces the notions of <em>modification events</em> and
<em>propagation conditions</em>, which refine the event-based model
of propagation and yield an efficient implementation. The
presented architecture is the basis of Gecode.
</p>
EOA
	    ),

      "CastanedaSchulteWahlberg:CP:2010" =>
      array("type" =>        "conference",
            "editor" =>      array("David Cohen"),
	    "booktitle" =>   "Sixteenth International Conference on Principles and Practice of Constraint Programming",
	    "year" =>        2010,
	    "month" =>       "SEP",
	    "address" =>     "St Andrews, UK",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "copyright" =>   $LNCS_COPY,
	    "DOI" =>         "10.1007/978-3-642-15396-9_48",
            "pages" =>       array(613,627),
            "volume" =>      6308,
	    "author" =>      array("castaneda","schulte","wahlberg"),
            "affiliation" => "KTH",
	    "title" =>       "Testing Continuous Double Auctions with a Constraint-based Oracle",
	    "abstract" =>    <<<EOA
<p>    
  Computer trading systems are essential for today's financial
  markets where the trading systems' correctness is of paramount
  economical significance. Automated random testing is a useful
  technique to find bugs in these systems, but it requires an
  independent system to decide the correctness of the system 
  under test (known as <em>oracle problem</em>). This paper
  introduces a constraint-based oracle for random testing of
  a real-world trading system. The oracle provides the expected
  results by generating and solving constraint models of the trading
  system's continuous double auction. Constraint programming is
  essential for the correctness of the test oracle as the logic
  for calculating trades can be mapped directly to constraint
  models. The paper shows that the generated constraint models
  can be solved efficiently. Most importantly, the approach is
  shown to be successful by finding errors in a deployed
  financial trading system and in its specification.
</p>
EOA
	    ),

     "SchulteTackLagerkvist:MPG:2010" =>
      array("type" =>        "doc",
            "selected" =>    1,
	    "title" =>       "Modeling and Programming with Gecode",
	    "year" =>        2010,
	    "author" =>      array("schulte","tack","lagerkvist"),
            "link"=>         "http://www.gecode.org/doc-latest/MPG.pdf",
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
  <p>    
   Modeling and Programming with Gecode provides comprehensive
   documentation of how to model and program with Gecode.
  </p>
  <p>
   The first part of the document explains modeling and solving
   constraint problems with Gecode. It explains how to program,
   compile, link, and execute these models. It provides an
   overview of integer, Boolean, and set variables and
   constraints, modeling support, search, and Gist. This is
   complemented by a collection of interesting case studies of
   how to model with Gecode.
  </p>
  <p>
   The remaining, more advanced, parts are about programming with
   Gecode. They explain in great detail and with numerous
   examples the concepts and techniques for programming
   constraints, branchings, search engines, and new variable
   types with Gecode. The parts' coverage puts users on par with
   Gecode's developers.
  </p>
EOA
	    ),
    
      "SchulteTack:CCoR:2009" =>
      array("type" =>        "corr",
            "title" => "View-based Propagator Derivation",
	    "year" =>     2009,
            "month" => "AUG",
            "link" =>        "http://arxiv.org/abs/0908.2050",
	    "author" =>    array("schulte","tack"),
            "affiliation" => "KTH",
	    "abstract" => <<<EOA
<p>	     
  When implementing a propagator for a constraint, one must
  decide about variants: When implementing min, should one
  also implement max?  Should one implement linear constraints
  both with unit and non-unit coefficients?  Constraint variants
  are ubiquitous: implementing them requires considerable (if not
  prohibitive) effort and decreases maintainability, but will
  deliver better performance than resorting to constraint
  decomposition.
</p>
<p>	     
  This paper shows how to use views to derive <em>perfect</em>
  propagator variants.  A model for views and derived propagators
  is introduced. Derived propagators are proved to be indeed
  perfect in that they inherit essential properties such as
  correctness and domain and bounds consistency. Techniques for
  systematically deriving propagators such as transformation,
  generalization, specialization, and type conversion are
  developed. The paper introduces an implementation architecture
  for views that is independent of the underlying constraint
  programming system.  A detailed evaluation of views implemented
  in Gecode shows that derived propagators are efficient and that
  views often incur no overhead.  Without views, Gecode would
  either require 180000 rather than 40000 lines of
  propagator code, or would lack many efficient propagator
  variants.  Compared to 8000 lines of code for views, the
  reduction in code for propagators yields a 1750% return on
  investment.
</p>
EOA
	    ),
      
      "ChuSchulteStuckey:CP:2009" =>
      array("type" =>        "conference",
            "selected" => 1,
            "editor" =>      array("Ian Gent"),
	    "booktitle" =>   "Fifteenth International Conference on Principles and Practice of Constraint Programming",
	    "year" =>        2009,
	    "month" =>       "SEP",
	    "address" =>     "Lisbon, Portugal",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "copyright" =>   $LNCS_COPY,
            "volume" =>      5732,
            "DOI" =>         "10.1007/978-3-642-04244-7_20",
	    "author" =>      array("chu","schulte","stuckey"),
            "pages" =>       array(226,241),
            "affiliation" => "KTH",
	    "title" =>       "Confidence-based Work Stealing in Parallel Constraint Programming",
	    "abstract" =>    <<<EOA
<p>    
  The most popular architecture for parallel search is work
  stealing: threads that have run out of work (nodes to be
  searched) steal from threads that still have work.  Work
  stealing not only allows for dynamic load balancing, but also
  determines which parts of the search tree are searched next.
  Thus the place from where work is stolen has a dramatic effect
  on the efficiency of a parallel search algorithm.
</p>
<p>
  This paper examines quantitatively how optimal work stealing
  can be performed given an estimate of the relative solution
  densities of the subtrees at each search tree node and relates
  it to the branching heuristic strength.
  An adaptive work stealing algorithm is presented that
  automatically performs different work stealing strategies based
  on the confidence of the branching heuristic at each node. Many
  parallel depth-first search patterns arise naturally from this
  algorithm. The algorithm produces near perfect or
  super linear algorithmic efficiencies on all problems tested.
  Real speedups using 8 threads range from 7 times to
  super linear.
</p>
EOA
	    ),

      "DelgadoJensenSchulte:CP:2009" =>
      array("type" =>        "conference",
            "editor" =>      array("Ian Gent"),
	    "booktitle" =>   "Fifteenth International Conference on Principles and Practice of Constraint Programming",
	    "year" =>        2009,
	    "month" =>       "SEP",
	    "address" =>     "Lisbon, Portugal",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "copyright" =>   $LNCS_COPY,
            "volume" =>      5732,
            "pages" =>       array(6,20),
            "DOI" =>         "10.1007/978-3-642-04244-7_4",
	    "author" =>      array("delgado","jensen","schulte"),
            "affiliation" => "KTH",
	    "title" =>       "Generating Optimal Stowage Plans for Container Vessel Bays",
	    "abstract" =>    <<<EOA
<p>    
Millions of containers are stowed every week with goods worth
billions of dollars, but container vessel stowage is an all but
neglected combinatorial optimization problem. In this paper, we
introduce a model for stowing containers in a vessel bay which is
the result of probably the longest collaboration to date with a
liner shipping company on automated stowage planning. We then
show how to solve this model efficiently in - to our knowledge -
the first application of CP to stowage planning using
state-of-the-art techniques such as extensive use of global
constraints, viewpoints, static and dynamic symmetry breaking,
decomposed branching strategies, and early failure detection. Our
CP approach outperforms an integer programming and column
generation approach in a preliminary study. Since a complete
model of this problem includes even more logical constraints, we
believe that stowage planning is a new application area for CP
with a high impact potential.
</p>
EOA
	    ),

      "LagerkvistSchulte:CP:2009" =>
      array("type" =>        "conference",
            "selected" => 1,
            "editor" =>      array("Ian Gent"),
	    "booktitle" =>   "Fifteenth International Conference on Principles and Practice of Constraint Programming",
	    "year" =>        2009,
	    "month" =>       "SEP",
	    "address" =>     "Lisbon, Portugal",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "copyright" =>   $LNCS_COPY,
            "volume" =>      5732,
            "pages" =>       array(524,538),
	    "author" =>      array("lagerkvist","schulte"),
            "DOI" =>         "10.1007/978-3-642-04244-7_42",
	    "title" =>       "Propagator Groups",
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
  This paper introduces propagator groups as an abstraction for
  controlling the execution of propagators as implementations of
  constraints. Propagator groups enable users of a constraint
  programming system to program how propagators within a group
  are executed.
</p>
<p>
  The paper exemplifies propagator groups for controlling both
  <em>propagation order</em> and <em>propagator interaction</em>.
  Controlling propagation order is applied to debugging
  constraint propagation and optimal constraint propagation for
  Berge-acyclic propagator graphs. Controlling propagator
  interaction by encapsulating failure and entailment is applied
  to general reification and constructive disjunction.  The paper
  describes an implementation of propagator groups (based on
  Gecode) that is applicable to any propagator-centered
  constraint programming system. Experiments show that groups
  incur little to no overhead and that the applications of groups
  are practically usable and efficient.
</p>
EOA
	    ),

      "ReischukSchulteEa:CP:2009" =>
      array("type" =>        "conference",
            "editor" =>      array("Ian Gent"),
	    "booktitle" =>   "Fifteenth International Conference on Principles and Practice of Constraint Programming",
	    "year" =>        2009,
	    "month" =>       "SEP",
	    "address" =>     "Lisbon, Portugal",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "copyright" =>   $LNCS_COPY,
            "volume" =>      5732,
            "pages" =>       array(692,706),
            "DOI" =>         "10.1007/978-3-642-04244-7_54",
	    "author" =>      array("reischuk","schulte","stuckey","tack"),
	    "title" =>       "Maintaining State in Propagation Solvers",
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
Constraint propagation solvers interleave propagation, removing
impossible values from variable domains, with search.  The solver
state is modified during propagation.  But search requires the
solver to return to a previous state. Hence a propagation solver
must determine how to maintain state during propagation and
forward and backward search.  This paper sets out the possible
ways in which a propagation solver can choose to maintain state,
and the restrictions that such choices place on the resulting
system.  Experiments illustrate the result of various choices for
the three principle state components of a solver: variables,
propagators, and dependencies between them.  This paper also
provides the first realistic comparison of trailing versus
copying for state restoration.
</p>
EOA
	    ),

      "SchulteTack:CP:2009" =>
      array("type" =>        "conference",
            "selected" => 1,
            "editor" =>      array("Ian Gent"),
	    "booktitle" =>   "Fifteenth International Conference on Principles and Practice of Constraint Programming",
	    "year" =>        2009,
	    "month" =>       "SEP",
	    "address" =>     "Lisbon, Portugal",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "copyright" =>   $LNCS_COPY,
            "volume" =>      5732,
            "pages" =>       array(723,730),
            "DOI" =>         "10.1007/978-3-642-04244-7_56",
	    "author" =>      array("schulte","tack"),
	    "title" =>       "Weakly Monotonic Propagators",
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
  Today's models for propagation-based constraint solvers require
  propagators as implementations of constraints to be at least
  contracting and monotonic.  These models do not comply with
  reality: today's constraint programming systems actually use
  <em>non-monotonic</em> propagators.  This paper introduces the
  first realistic model of constraint propagation by assuming a
  propagator to be <em>weakly monotonic</em> (complying with the
  constraint it implements).  Weak monotonicity is shown to be
  the minimal property that guarantees constraint propagation to
  be sound and complete.  The important insight is that weak
  monotonicity makes propagation <em>in combination</em> with search well
  behaved.  A case study suggests that non-monotonicity can be
  seen as an opportunity for more efficient propagation.
</p>
EOA
	    ),

     "FlenerCarlssonSchulte:IS:2009" =>
      array("type" =>        "article",
	    "title" =>       "Constraint Programming in Sweden",
	    "journal" =>     "IEEE Intelligent Systems",
	    "publisher" =>   "IEEE Press",
	    "year" =>        2009,
	    "volume" =>      24,
            "number" =>      2,
            "pages" =>       array(87,89),
            "month" =>       "March/April",
            "DOI" =>         "10.1109/MIS.2009.25",
            "link" =>        "http://doi.ieeecomputersociety.org/10.1109/MIS.2009.25",
	    "author" =>      array("flener","carlsson","schulte"),
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
Many important problems must be solved by intelligent search -
for example, problems in scheduling, rostering, configuration,
facility location, biology, finance, circuit layout, and
hard/software specification checking. Constraint programming (CP)
is rapidly becoming the method of choice in some areas, such as
scheduling and configuration. A major difficulty lies in
accelerating such (optimal) choices. This ranges from problem
modeling to actual problem solving.  Real-world success stories
abound. Here, we survey CP research and development in Sweden.
</p>

EOA
	    ),
    

     "SchulteStuckey:TOPLAS:2008" =>
      array("type" =>        "article",
            "selected" => 1,
	    "title" =>       "Efficient Constraint Propagation Engines",
	    "journal" =>     $TOPLAS,
	    "publisher" =>   $ACM,
	    "year" =>        2008,
	    "month" =>       "DEC",
            "volume" =>      31,
            "number" =>      1,
	    "author" =>      array("schulte","stuckey"),
            "pages" =>       array("2:1","2:43"),
	    "DOI" =>         "10.1145/1452044.1452046",
            "copyright" =>   ACM_COPY("2008"),
            "acm" =>         "http://dl.acm.org/authorize?161127",
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
  This paper presents a model and implementation techniques for
  speeding up constraint propagation.  Three fundamental
  approaches to improving constraint propagation based on
  propagators as implementations of constraints are explored:
  keeping track of which propagators are at fixpoint, choosing
  which propagator to apply next, and how to combine several
  propagators for the same constraint.
</p>
<p>
  We show how idempotence reasoning and events help track
  fixpoints more accurately.  We improve these methods by using
  them dynamically (taking into account current domains to
  improve accuracy).  We define priority-based approaches to
  choosing a next propagator and show that dynamic priorities can
  improve propagation.  We illustrate that the use of multiple
  propagators for the same constraint can be advantageous with
  priorities, and introduce staged propagators that combine the
  effects of multiple propagators with priorities for greater
  efficiency.
</p>
EOA
	    ),
    
      "ChuSchulteStuckey:CICLOPS:2008" =>
      array("type" =>        "workshop",
	    "title" =>       "Confidence based Work Stealing",
            "editor" =>      array("Manuel Carro","Bart Demoen"),
	    "booktitle" =>   "Proceedings of the Eigth International Colloquium on Implementation of Constraint and Logic Programming Systems",
	    "year" =>        2008,
	    "month" =>       "DEC",
	    "author" =>      array("chu","schulte","stuckey"),
	    "address" =>     "Udine, Italy",
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
  In parallel constraint solving, work stealing not only allows for dynamic
  load balancing, but also determines which parts of the search tree are
  searched next. Thus the place from where work is stolen has a dramatic effect
  on the efficiency of a parallel search algorithm. In this paper we examine
  quantitatively how optimal work stealing can be performed given an
  estimate of the relative solution densities of the subtrees at each node in the search
  tree and show how this is related to the branching heuristic strength. We propose an adaptive work stealing algorithm that automatically
  performs different work stealing strategies based on the strength of the
  branching heuristic at each node. Search patterns such as parallel versions of DFS, IDFS, LDS, DDS and many others arise naturally from our algorithm. Our algorithm is able to produce near perfect or
  super linear algorithmic efficiencies on all problems tested. Real
  speedups using 8 threads ranged from 4-5 times speedup to super linear
  speedup.
</p>
EOA
	    ),

      "SchulteStuckey:ICLP:2008" =>
      array("type" =>        "conference",
	    "title" =>       "Dynamic Analysis of Bounds versus Domain Propagation",
            "editor" =>      array("Maria Garcia de la Banda","Enrico Pontelli"),
	    "booktitle" =>   "Twenty Fourth International Conference on Logic Programming",
	    "year" =>        2008,
	    "month" =>       "DEC",
	    "author" =>      array("schulte","stuckey"),
	    "address" =>     "Udine, Italy",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "copyright" =>   $LNCS_COPY,
            "volume" =>      5366,
            "pages" =>       array(332,346),
            "affiliation" => "KTH",
	    "DOI" =>         "10.1007/978-3-540-89982-2_32",
            "acm" =>         "http://dl.acm.org/authorize?072485",
	    "abstract" =>    <<<EOA
<p>    
  Constraint propagation solvers interleave propagation (removing
  impossible values from variable domains) with search.
  Previously, Schulte and Stuckey introduced the use of static
  analysis to determine where in a constraint program domain
  propagators can be replaced by more efficient bounds
  propagators and still ensure that the same search space is
  traversed.
</p>
<p>  
  This paper introduces a dynamic yet considerably simpler
  approach to uncover the same information. The information is
  obtained by a linear time traversal of an analysis graph that
  straightforwardly reflects the properties of propagators
  implementing constraints.  Experiments confirm that the simple
  dynamic method is efficient and that it can be used interleaved
  with search, taking advantage of the simplification of the
  constraint graph that arises from search.
</p>
EOA
	    ),

      "SchulteTack:CP:2008" =>
      array("type" =>        "conference",
	    "title" =>       "Perfect Derived Propagators",
            "editor" =>      array("Peter J. Stuckey"),
	    "booktitle" =>   "Fourteenth International Conference on Principles and Practice of Constraint Programming",
	    "year" =>        2008,
	    "month" =>       "SEP",
	    "author" =>      array("schulte","tack"),
	    "address" =>     "Sydney, Australia",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "volume" =>      5202,
            "copyright" =>   $LNCS_COPY,
            "pages" =>       array(571,575),
	    "DOI" =>         "10.1007/978-3-540-85958-1_44",
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
  When implementing a propagator for a constraint, one must decide
  about variants: When implementing min, should one also implement
  max?  Should one implement linear equations both with and without
  coefficients?  Constraint variants are ubiquitous: implementing them
  requires considerable effort, but yields better 
  performance.
</p>
<p>
  This paper shows how to use variable views to derive
  <i>perfect</i> propagator variants: derived propagators inherit
  essential properties such as correctness and domain and bounds
  completeness.
</p>
EOA
	    ),

      "SchulteTack:CCoR:2008" =>
      array("type" =>        "corr",
	    "title" =>       "Perfect Derived Propagators",
	    "year" =>        2008,
	    "month" =>       "JUN",
	    "author" =>      array("schulte","tack"),
            "link" =>        "http://arxiv.org/abs/0806.1806",
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
  When implementing a propagator for a constraint, one must decide
  about variants: When implementing min, should one also implement
  max?  Should one implement linear equations both with and without
  coefficients?  Constraint variants are ubiquitous: implementing them
  requires considerable (if not prohibitive) effort and decreases
  maintainability, but will deliver better performance.
</p>
<p>
  This paper shows how to use variable views, previously introduced
  for an implementation architecture, to derive <i>perfect</i>
  propagator variants.  A model for views and derived propagators is
  introduced. Derived propagators are proved to be indeed perfect in
  that they inherit essential properties such as correctness and
  domain and bounds consistency. Techniques for systematically
  deriving propagators such as transformation, generalization,
  specialization, and channeling are developed for several variable
  domains. We evaluate the massive impact of derived
  propagators. Without derived propagators, Gecode would require
  140000 rather than 40000 lines of code for propagators.
</p>
EOA
	    ),

      "SchulteStuckey:PPDP:2008" =>
      array("type" =>        "conference",
	    "title" =>       "Dynamic Variable Elimination During Propagation Solving",
	    "editor" =>      array("Sergio Antoy"),
	    "booktitle" =>   "Tenth International ACM SIGPLAN Symposium on Principles and Practice of Declarative Programming",
	    "year" =>        2008,
	    "month" =>       "JUL",
	    "author" =>      array("schulte","stuckey"),
	    "pages" =>       array(247,257),
	    "address" =>     "Valencia, Spain",
	    "publisher" =>   $ACM,
            "copyright" =>   ACM_COPY("2008"),
            "affiliation" => "KTH",
	    "DOI" =>         "10.1145/1389449.1389480",	
	    "abstract" =>    <<<EOA
<p>    
  Constraint propagation solvers interleave propagation (removing
  impossible values from variables domains) with search.
  Propagation is performed by executing propagators (removing
  values) implementing constraints (defining impossible values).
  In order to specify constraint problems with a propagation
  solver often many new intermediate variables need to be
  introduced.  Each variable plays a role in calculating the
  value of some expression.  But as search proceeds not all of
  these expressions will be of interest any longer, but the
  propagators implementing them will remain active.  In this
  paper we show how we can analyse the propagation graph of the
  solver in linear time to determine intermediate variables that
  can be removed without effecting the result.  Experiments show
  that applying this analysis can reduce the space and time
  requirements for constraint propagation on example problems.
</p>
EOA
	    ),
    
      "LagerkvistSchulte:CP:2007" =>
      array("type" =>        "conference",
            "selected" => 1,
	    "title" =>       "Advisors for Incremental Propagation",
            "editor" =>      array("Christian Bessière"),
	    "booktitle" =>   "Thirteenth International Conference on Principles and Practice of Constraint Programming",
	    "year" =>        2007,
	    "month" =>       "SEP",
	    "author" =>      array("lagerkvist","schulte"),
            "pages" =>       array(409,422),
	    "address" =>     "Providence, RI, USA",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "copyright" =>   $LNCS_COPY,
            "volume" =>      4741,
	    "DOI" =>         "10.1007/978-3-540-74970-7_30",
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
  While incremental propagation for global constraints is
  recognized to be important, little research has been devoted to
  how propagator-centered constraint programming systems should
  support incremental propagation.  This paper introduces
  advisors as a simple and efficient, yet widely applicable
  method for supporting incremental propagation in a
  propagator-centered setting. The paper presents how advisors
  can be used for achieving different forms of incrementality and
  evaluates cost and benefit for several global constraints.
</p>
EOA
	    ),

      "MichelSchulteVanHentenryck:TCP:2007" =>
      array("type" =>        "incollection",
	    "title" =>       "Constraint Programming Tools",
            "author" =>      array("michel","schulte","vanhentenryck"),
            "editor" =>      array("Frédéric Benhamou", "Narendra Jussien", 
	                           "Barry O'Sullivan"),
            "booktitle" =>   "Trends in Constraint Programming",
            "chapter" =>     2,
            "publisher" =>   "ISTE",
            "address" =>     "London, UK",
            "year" =>        2007,
            "pages" =>       array(41,57),
            "affiliation" => "KTH",
            "link" =>        "http://www.iste.co.uk/index.php?isbn=9781905209972",
	    ),

    "SchulteStuckey:CCoR:2006" =>
      array("type" =>        "corr",
	    "title" =>       "Efficient Constraint Propagation Engines",
	    "year" =>        2006,
	    "month" =>       "OCT",
	    "author" =>      array("schulte","stuckey"),
            "link" =>        "http://arxiv.org/abs/cs.AI/0611009",
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
  This paper presents a model and implementation techniques for
  speeding up constraint propagation.  Three fundamental
  approaches to improving constraint propagation based on
  propagators as implementations of constraints are explored:
  keeping track of which propagators are at fixpoint, choosing
  which propagator to apply next, and how to combine several
  propagators for the same constraint.
</p>
<p>
  We show how idempotence reasoning and events help track
  fixpoints more accurately.  We improve these methods by using
  them dynamically (taking into account current domains to
  improve accuracy).  We define priority-based approaches to
  choosing a next propagator and show that dynamic priorities can
  improve propagation.  We illustrate that the use of multiple
  propagators for the same constraint can be advantageous with
  priorities, and introduce staged propagators that combine the
  effects of multiple propagators with priorities for greater
  efficiency.
</p>
EOA
	    ),
    
      "TackSchulteSmolka:CP:2006" =>
      array("type" =>        "conference",
	    "title" =>       "Generating Propagators for Finite Set Constraints",
            "editor" =>      array("Frédéric Benhamou"),
	    "booktitle" =>   "Twelfth International Conference on Principles and Practice of Constraint Programming",
	    "year" =>        2006,
	    "month" =>       "SEP",
	    "author" =>      array("tack","schulte","smolka"),
	    "address" =>     "Nantes, France",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "volume" =>      4204,
            "copyright" =>   $LNCS_COPY,
            "DOI" =>         "10.1007/11889205_41",
            "pages" =>       array(575,589),
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
  Ideally, programming propagators as implementations of
  constraints should be an entirely declarative specification process
  for a large class of constraints: a high-level declarative
  specification is automatically translated into an efficient
  propagator. This paper introduces the use of existential
  monadic second-order logic as declarative
  specification language for finite set propagators. The approach taken in
  the paper is to automatically derive projection propagators (involving a
  single variable only) implementing
  constraints described by formulas. By this, the paper
  transfers the ideas of indexicals to finite set constraints
  while considerably increasing the level of
  abstraction available with indexicals. The paper proves soundness
  and completeness of the derived propagators and presents a run-time
  analysis, including techniques for efficiently executing projectors
  for <i>n</i>-ary constraints.
</p>
EOA
	    ),

      "SchulteCarlsson:CPH:2006" =>
      array("type" =>        "incollection",
            "selected" => 1,
	    "title" =>       "Finite Domain Constraint Programming Systems",
            "author" =>      array("schulte","carlsson"),
            "editor" =>      array("Francesca Rossi", "Peter van Beek", 
	                           "Toby Walsh"),
            "booktitle" =>   "Handbook of Constraint Programming",
            "series" =>      "Foundations of Artificial Intelligence",
            "chapter" =>     14,
            "publisher" =>   "Elsevier Science Publishers",
            "address" =>     "Amsterdam, The Netherlands",
            "year" =>        2006,
            "pages" =>       array(495,526),
            "affiliation" => "KTH",
            "copyright" =>   "&copy; 2006 Elsevier, all rights reserved. This copy is only for educational and scientific purposes"
	    ),

      "MichelFruhwirthSchulte:CPH:2006" =>
      array("type" =>        "incollection",
	    "title" =>       "Constraints in Procedural and Concurrent Languages",
            "author" =>      array("michel","fruhwirth","schulte"),
            "editor" =>      array("Francesca Rossi", "Peter van Beek", 
	                           "Toby Walsh"),
            "booktitle" =>   "Handbook of Constraint Programming",
            "series" =>      "Foundations of Artificial Intelligence",
            "chapter" =>     13,
            "publisher" =>   "Elsevier Science Publishers",
            "address" =>     "Amsterdam, The Netherlands",
            "year" =>        2006,
            "pages" =>       array(453,494),
            "affiliation" => "KTH",
            "copyright" =>   "&copy; 2006 Elsevier, all rights reserved. This copy is only for educational and scientific purposes"
	    ),

      "SchulteTack:Advances:2006" =>
      array("type" =>        "incollection",
	    "title" =>       "Views and Iterators for Generic Constraint Implementations",
	    "booktitle" =>   "Recent Advances in Constraints (2005)",
	    "year" =>        2006,
	    "author" =>      array("schulte","tack"),
	    "publisher" =>   $SPR,
            "series" =>      $LNAI,
            "copyright" =>   $LNCS_COPY,
            "DOI" =>         "10.1007/11754602_9",
            "pages" =>       array(118,132),
            "volume" =>      3978,
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
  This paper introduces an architecture for generic constraint
  implementations based on variable views and range iterators.  Views
  allow, for example, to scale, translate, and negate variables. The
  paper shows how to make constraint implementations generic and how
  to reuse a single generic implementation with different views for
  different constraints.  A wide range of applications of views
  exemplifies their usefulness and their potential for simplifying
  constraint implementations.  We introduce domain operations
  compatible with views based on range iterators.  The paper evaluates
  the applicability of the approach as well as different
  implementation techniques for the presented architecture.
</p>
EOA
	    ),

      "SchulteTack:CICLOPS:2005" =>
      array("type" =>        "workshop",
	    "title" =>       "Views and Iterators for Generic Constraint Implementations",
            "editor" =>      array("Christian Schulte","Fernando Silva",
		                   "Ricardo Rocha"),
	    "booktitle" =>   "Proceedings of the Fifth International Colloqium on Implementation of Constraint and Logic Programming Systems",
	    "year" =>        2005,
	    "month" =>       "OCT",
	    "author" =>      array("schulte","tack"),
	    "address" =>     "Sitges, Spain",
            "pages" =>       array(37,48),
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
This paper introduces an architecture for
generic constraint implementations based on variable views and
range iterators.  Views allow, for example, to scale, translate,
and negate variables. The paper shows how to make constraint
implementations generic and how to reuse a single generic
implementation with different views for different constraints.
Applications of views exemplify their usefulness and their
potential for simplifying constraint implementations.  We
introduce domain operations compatible with views based on range
iterators.  The
paper evaluates different implementation techniques
for the presented architecture.
</p>
EOA
	    ),

      "SchulteTack:CP:2005" =>
      array("type" =>        "conference",
	    "title" =>       "Views and Iterators for Generic Constraint Implementations",
            "editor" =>      array("Peter van Beek"),
	    "booktitle" =>   "Eleventh International Conference on Principles and Practice of Constraint Programming",
	    "year" =>        2005,
	    "month" =>       "OCT",
	    "author" =>      array("schulte","tack"),
	    "address" =>     "Sitges, Spain",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "volume" =>      3709,
            "pages" =>       array(817,821),
            "copyright" =>   $LNCS_COPY,
            "DOI" =>         "10.1007/11564751_71",
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
This paper introduces an architecture for generic constraint
implementations based on variable views and range iterators.
Views allow, for example, to scale, translate, and negate
variables. The paper shows how to make constraint implementations
generic and how to reuse a single generic implementation with
different views for different constraints.  Applications of views
exemplify their usefulness and their potential for simplifying
constraint implementations.  We introduce domain operations
compatible with views based on range iterators to access and
modify entire variable domains.
</p>
EOA
	    ),

      "SchulteStuckey:TOPLAS:2005" =>
      array("type" =>        "article",
	    "title" =>       "When Do Bounds and Domain Propagation Lead to the Same Search Space?",
	    "journal" =>     $TOPLAS,
	    "year" =>        2005,
	    "month" =>       "MAY",
	    "author" =>      array("schulte","stuckey"),
	    "publisher" =>   $ACM,
            "pages" =>       array(388,425),
            "volume" =>      27,
            "number" =>      3,
            "copyright" =>   ACM_COPY("2005"),
	    "DOI" =>         "10.1145/1065887.1065889",
            "affiliation" => "KTH",
            "acm" =>         "http://dl.acm.org/authorize?860977",
	    "abstract" =>    <<<EOA
<p>    
  This paper explores the question of when two propagation-based
  constraint systems have the same behaviour, in terms of search
  space.  We categorise the behaviour of domain and bounds
  propagators for primitive constraints, and provide theorems
  that allow us to determine propagation behaviours for
  conjunctions of constraints.  We then show how we can use this
  to analyse CLP(FD) programs to determine when we can safely
  replace domain propagators by more efficient bounds propagators
  without increasing search space. Empirical evaluation shows
  that programs optimized by the analysis' results are
  considerably more efficient.
</p>
EOA
	    ),

      "HavelkaSchulteEa:MOZ:2004" =>
      array("type" =>        "conference",
	    "title" =>       "Thread-based Mobility in Oz",
	    "year" =>        2004,
	    "author" =>      array("havelka","schulte","brand","haridi"),
            "editor" =>      array("Peter Van Roy"),
	    "booktitle" =>   "Multiparadigm Programming in Mozart/Oz: Second International Conference",
	    "year" =>        2004,
	    "pages" =>       array(137,148),
	    "month" =>       "OCT",
	    "address" =>     "Charleroi, Belgium",
	    "series" =>      $LNCS,
            "volume" =>      3389,
            "copyright" =>   $LNCS_COPY,
            "affiliation" => "KTH",
	    "link" =>        "http://springerlink.metapress.com/openurl.asp?genre=article&issn=0302-9743&volume=3389&spage=137",
	    "abstract" =>    <<<EOA
<p>    
  Strong mobility enables migration of entire computations combining
  code, data, and execution state (such as stack and program counter)
  between sites of computation. This is in contrast to weak mobility
  where migration is confined to just code and data.  Strong mobility
  is essential for many applications where reconstruction of execution
  states is either difficult or even impossible: load balancing,
  reduction of network latency and traffic, and resource-related
  migration, just to name a few.  This paper presents a model,
  programming abstractions, implementation, and evaluation of
  thread-based strong mobility.  The model extends and takes advantage
  of a distributed programming model based on automatic
  synchronization through dataflow variables.  It comes as a natural
  extension of dataflow computing which carefully separates issues
  concerning distribution and mobility. The programming abstractions
  capture various migration scenarios which differ in how the source
  and destination site relate to the site initiating migration.  The
  implementation is based on replicating concurrent lightweight
  threads between sites controlled by migration managers.
</p>
EOA
	    ),

    "SchulteStuckey:CP:2004" =>
      array("type" =>        "conference",
	    "title" =>       "Speeding Up Constraint Propagation",
            "editor" =>      array("Mark Wallace"),
	    "booktitle" =>   "Tenth International Conference on Principles and Practice of Constraint Programming",
	    "year" =>        2004,
	    "month" =>       "SEP",
	    "author" =>      array("schulte","stuckey"),
	    "address" =>     "Toronto, Canada",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS,
            "volume" =>      3258,
	    "pages" =>       array(619,633),
            "copyright" =>   $LNCS_COPY,
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
  This paper presents a model and implementation techniques for
  speeding up constraint propagation.  Two fundamental approaches
  to improving constraint propagation are explored: keeping track
  of which propagators are at fixpoint, and choosing which
  propagator to apply next.  We show how idempotence reasoning
  and events help track fixpoints more accurately.  We improve
  these methods by using them dynamically (taking into account
  current domains to improve accuracy).  We define
  priority-based approaches to choosing a next propagator and
  show that dynamic priorities can improve propagation.  We
  illustrate that the use of multiple propagators for the same
  constraint can be advantageous with priorities, and introduce
  staged propagators which combine the effects of multiple
  propagators with priorities for greater efficiency.
</p>
EOA
	    ),
    

"DrejhammarSchulte:CICLOPS:2004" =>
      array("type" =>        "workshop",
	    "title" =>       "Implementation Strategies for Single Assignment Variables",
	    "booktitle" =>   "Colloquium on  Implementation of Constraint and LOgic Programming Systems (CICLOPS 2004)",
	    "year" =>        2004,
	    "month" =>       "SEP",
	    "author" =>      array("drejhammar","schulte"),
	    "address" =>     "Saint Malo, France",
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
Flow Java integrates single assignment variables (logic
variables) into Java. This paper presents and compares three
implementation strategies for single assignment variables in Flow
Java. One strategy uses forwarding and dereferencing while
the two others are variants of Taylor's scheme. The paper
introduces how to adapt Taylor's scheme for a concurrent language
based on operating system threads, token equality, and update of
data structures. Evaluation of the strategies clarifies that the
key issue for efficiency is reducing memory usage.
</p>
EOA
	    ),
    

"DrejhammarSchulteEa:ICLP:2003" =>
      array("type" =>        "conference",
	    "title" =>       "Flow {Java}: Declarative Concurrency for {Java}",
	    "editor" =>      array("Catuscia Palamidessi"),
	    "booktitle" =>   "Proceedings of the Nineteenth International Conference on Logic Programming",
	    "year" =>        2003,
	    "month" =>       "DEC",
	    "author" =>      array("drejhammar","schulte","haridi","brand"),
	    "pages" =>       array(346,360),
	    "address" =>     "Mumbai, India",
	    "publisher" =>   $SPR,
            "series" =>      $LNCS, 
            "copyright" =>   $LNCS_COPY,
            "volume" =>      2916,
            "note" =>        "Received the best application paper award",
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
Logic variables pioneered by (concurrent) logic
and concurrent constraint programming are powerful mechanisms for
automatically synchronizing concurrent computations. They support
a declarative model of concurrency that avoids explicitly
suspending and resuming computations.  This paper presents
<i>Flow Java</i> which conservatively extends Java with single
assignment variables and futures as variants of logic variables.
The extension is conservative with respect to object-orientation,
types, parameter passing, and concurrency in Java. Futures
support secure concurrent abstractions and are essential for
seamless integration of single assignment variables into Java. We
show how Flow Java supports the construction of simple and
concise concurrent programming abstractions.  We present how to
moderately extend compilation and the runtime architecture of an
existing Java implementation for Flow Java.  Evaluation using standard Java
benchmarks shows that in most cases the overhead is between 10%
and 40%.  For some pathological cases the runtime increases by
up to 75%.</p>
EOA
	    ),
    

"VanRoyBrandEa:TPLP:2003" =>
      array("type" =>        "article",
	    "title" =>       "Logic programming in the context of multiparadigm programming: the {Oz} experience",
	    "author" =>      array("vanroy", "brand", "duchier", "haridi", "henz", "schulte"),
	    "journal" =>     "Theory and Practice of Logic Programming",
	    "publisher" =>   "Cambridge University Press",
	    "year" =>        2003,
            "month" =>       "NOV",
            "pages" =>       array(715,763),
            "volume" =>      3,
            "number" =>      6,
            "affiliation" => "KTH",
	    "abstract" =>    <<<EOA
<p>    
Oz is a multiparadigm language that supports logic programming as one of its major paradigms. A multiparadigm language is designed to support different programming paradigms (logic, functional, constraint, object-oriented, sequential, concurrent, etc.) with equal ease. This article has two goals: to give a tutorial of logic programming in Oz and to show how logic programming fits naturally into the wider context of multiparadigm programming. Our experience shows that there are two classes of problems, which we call algorithmic and search problems, for which logic programming can help formulate practical solutions. Algorithmic problems have known efficient algorithms. Search problems do not have known efficient algorithms but can be solved with search. The Oz support for logic programming targets these two problem classes specifically, using the concepts needed for each. This is in contrast to the Prolog approach, which targets both classes with one set of concepts, which results in less than optimal support for each class. We give examples that can be run interactively on the Mozart system, which implements Oz. To explain the essential difference between algorithmic and search programs, we define the Oz execution model. This model subsumes both concurrent logic programming (committed-choice-style) and search-based logic programming (Prolog-style). Furthermore, as consequences of its multiparadigm nature, the model supports new abilities such as first-class top levels, deep guards, active objects, and sophisticated control of the search process. Instead of Horn clause syntax, Oz has a simple, fully compositional, higher-order syntax that accommodates the abilities of the language. We give a brief history of Oz that traces the development of its main ideas and we summarize the lessons learned from this work. Finally, we give many entry points into the Oz literature. 
</p>
EOA
	    ),

"VanRoyBrandEa:CCoR:2002" =>
      array("type" =>        "corr",
	    "title" =>       "Logic programming in the context of multiparadigm programming: the {Oz} experience",
	    "author" =>      array("vanroy", "brand", "duchier", "haridi", "henz", "schulte"),
	    "link" =>        "http://arxiv.org/abs/cs.PL/0208029",
	    "year" =>        2002,
            "month" =>       "AUG",
            "affiliation" => "SU",
	    "abstract" =>    <<<EOA
<p>    
Oz is a multiparadigm language that supports logic programming as one of its major paradigms. A multiparadigm language is designed to support different programming paradigms (logic, functional, constraint, object-oriented, sequential, concurrent, etc.) with equal ease. This article has two goals: to give a tutorial of logic programming in Oz and to show how logic programming fits naturally into the wider context of multiparadigm programming. Our experience shows that there are two classes of problems, which we call algorithmic and search problems, for which logic programming can help formulate practical solutions. Algorithmic problems have known efficient algorithms. Search problems do not have known efficient algorithms but can be solved with search. The Oz support for logic programming targets these two problem classes specifically, using the concepts needed for each. This is in contrast to the Prolog approach, which targets both classes with one set of concepts, which results in less than optimal support for each class. We give examples that can be run interactively on the Mozart system, which implements Oz. To explain the essential difference between algorithmic and search programs, we define the Oz execution model. This model subsumes both concurrent logic programming (committed-choice-style) and search-based logic programming (Prolog-style). Furthermore, as consequences of its multiparadigm nature, the model supports new abilities such as first-class top levels, deep guards, active objects, and sophisticated control of the search process. Instead of Horn clause syntax, Oz has a simple, fully compositional, higher-order syntax that accommodates the abilities of the language. We give a brief history of Oz that traces the development of its main ideas and we summarize the lessons learned from this work. Finally, we give many entry points into the Oz literature. 
</p>
EOA
	    ),

      "Schulte:LNAI:2002" =>
      array("type" =>        "book",
	    "title" =>       "Programming Constraint Services",
	    "author" =>      array("schulte"),
	    "year" =>        2002,
	    "month" =>       "MAR",
	    "series" =>      $LNAI,
	    "publisher" =>   $SPR,
            "volume" =>      2302,
	    "link" =>        "http://link.springer.de/link/service/series/0558/tocs/t2302.htm",
            "affiliation" => "SU",
            "abstract" =>    <<<EOA
<p>
Constraint programming is an approach to modeling and solving
combinatorial problems that has proven succesful in many
applications. Building on techniques developed in AI, logic
programming and operations research, constraint programming is based
on an abstraction that decomposes the problem solver into a reusable
constraint engine and a declarative program modeling the problem.
</p>
<p>
This book is concerned with the architecture and implementation of
constraint engines. The author's main contribution is that constraint
services, such as search and combinators, are made programmable; this
is achieved by devising computation spaces as simple abstraction for
programming constraint services at a high level. State-of-the-art and
novel search strategies, such as visual interactive search and
parallel search are covered.
</p>
<p>
The book is indispensible reading for anyone seriously interested in
constraint technology.
</p>
EOA
            ),

      "SchulteStuckey:PPDP:2001" =>
      array("type" =>        "conference",
	    "title" =>       "When Do Bounds and Domain Propagation Lead to the Same Search Space",
	    "editor" =>      array("Harald Søndergaard"),
	    "booktitle" =>   "Third ACM SIGPLAN International Conference on Principles and Practice of Declarative Programming",
	    "year" =>        2001,
	    "month" =>       "SEP",
	    "author" =>      array("schulte","stuckey"),
	    "pages" =>       array(115,126),
	    "address" =>     "Florence, Italy",
	    "publisher" =>   $ACM,
            "affiliation" => "SU",
            "acm" =>         "http://dl.acm.org/authorize?691626",
	    "abstract" =>    <<<EOA
<p>    
This paper explores the question of when two propagation-based
constraint systems have the same behaviour, in terms of search
  space.  We categorise the behaviour of domain and bounds
  propagators for primitive constraints, and provide theorems
  that allow us to determine propagation behaviours for
  conjunctions of constraints.  We then show how we can use this
  to analyse CLP(FD) programs to determine when we can safely
  replace domain propagators by more efficient bounds propagators
  without increasing search space.
</p>
EOA
	    ),
    
      "Schulte:PhD:2000" =>
      array("type" =>        "phdthesis",
	    "title" =>       "Programming Constraint Services",
	    "author" =>      array("schulte"),
	    "school" =>      "Universität des Saarlandes, Naturwissenschaftlich-Technische Fakultät I, Fachrichtung Informatik",
	    "typetype" =>    "Doctoral Dissertation",
	    "address" =>     "Saarbrücken, Germany",
	    "year" =>        2000,
            "affiliation" => "SU",
	    "abstract" =>    <<<EOA
<p>
This thesis presents design, application, implementation, and
   evaluation of computation spaces as abstractions for
   programming constraint services at a high level.  Spaces are
   seamlessly integrated into a concurrent programming language
   and make constraint-based computations compatible with
   concurrency through encapsulation.
</p>
<p>
Spaces are applied to search and combinators as essential
   constraint services. State-of-the-art and new search engines
   such as visual interactive search and parallel search are
   covered.  Search is expressive and concurrency-compatible by
   using copying rather than trailing. Search is space and time
   efficient by using recomputation.  Composable combinators, also
   known as deep-guard combinators, stress the control facilities
   and concurrency integration of spaces.
</p>
<p>The implementation of spaces comes as an orthogonal extension
   to the implementation of the underlying programming language.
   The resulting implementation is shown to be competitive with
   existing constraint programming systems.
</p>
EOA
	    ),

      "Schulte:TRICS:2000" =>
      array("type" =>        "workshop",
	    "title" =>       "Parallel Search Made Simple",
	    "editor" =>      array("Nicolas Beldiceanu", "Warwick Harvey",
				   "Martin Henz", "François Laburthe", "Eric Monfroy",
				   "Tobias Müller", "Laurent Perron", "Christian Schulte"),
	    "booktitle" =>   "Proceedings of TRICS: Techniques foR Implementing Constraint programming Systems, a post-conference workshop of CP 2000",
	    "address" =>     "Singapore",
	    "year" =>        2000,
            "month" =>       "SEP",
            "affiliation" => "SU",
	    "author" =>      array("schulte"),
	    "abstract" =>    <<<EOA
<p>
Search in constraint programming is a time consuming task.
  Search can be speeded up by exploring subtrees of a search tree
  in parallel. This paper presents distributed search engines
  that achieve parallelism by distribution across networked
  computers.  The main point of the paper is a simple design of
  the parallel search engine. Simplicity comes as an immediate
  consequence of clearly separating search, concurrency, and
  distribution. The obtained distributed search engines are
  simple yet offer substantial speedup on standard network
  computers.
</p>
EOA
	    ),

      "Schulte:PADL:2000" =>
      array("type" =>        "conference",
	    "title" =>       "Programming Deep Concurrent Constraint Combinators",
	    "editor" =>      array("Enrico Pontelli", "Vítor Santos Costa"),
	    "booktitle" =>   "Practical Aspects of Declarative Languages. PADL 2000",
	    "publisher" =>   $SPR,
	    "series" =>      $LNCS,
	    "volume" =>      1753,
	    "address" =>     "Boston, MA, USA",
	    "year" =>        2000,
            "copyright" =>   $LNCS_COPY,
	    "pages" =>       array(215,229),
	    "author" =>      array("schulte"),
            "affiliation" => "SU",
	  "abstract" => <<<EOA
<p>   
Constraint combination methods are essential for a
flexible constraint programming system. This paper
presents deep concurrent constraint combinators
based on computation spaces as combination
mechanism. It introduces primitives and techniques
needed to program constraint combinators from
computation spaces.  The paper applies computation
spaces to a broad range of combinators: negation,
generalized reification, disjunction, and
implication. Even though computation spaces have
been conceived in the context of Oz, they are
mainly programming language independent. This
point is stressed by discussing them here in the
context of Standard ML with concurrency features.
</p>
EOA
	    ),

      "Schulte:ICLP:1999" =>
      array("type" =>      "conference",
	    "author" =>    array("schulte"),
	    "title" =>     "Comparing Trailing and Copying for Constraint Programming",
	    "editor" =>    array("Danny De Schreye"),
	    "booktitle" => "Proceedings of the Sixteenth International Conference on Logic Programming",
	    "year" =>      1999,
	    "address" =>   "Las Cruces, NM, USA",
	    "pages" =>     array(275,289),
	    "publisher" => $MIT,
            "affiliation" => "SU",
	    "abstract" =>  <<<EOA
<p>
A central service of a constraint programming
system is search. In almost all constraint
programming systems search is based on trailing,
which is well understood and known to be
efficient.  This paper compares trailing to
copying. Copying offers more expressiveness as
required by parallel and concurrent
systems. However, little is known how trailing
compares to copying as it comes to implementation
effort, runtime efficiency, and memory
requirements. This paper discusses these issues.
</p>
<p>
Execution speed of a copying-based system is shown
to be competitive with state-of-the-art
trailing-based systems. For the first time, a
detailed analysis and comparison with respect to
memory usage is made.  It is shown how
recomputation decreases memory requirements which
can be prohibitive for large problems with copying
alone. The paper introduces an adaptive
recomputation strategy that is shown to speedup
search while keeping memory consumption low. It is
demonstrated that copying with recomputation
outperforms trailing on large problems with
respect to both space and time.
</p>
EOA
	    ),

      "DuchierKornstaedtEa:DRAFT:1998" =>
      array("type" => "draft",
	    "title" => "A Higher-order Module Discipline with Separate Compilation, Dynamic Linking, and Pickling",
	    "year" =>         1998,
	    "author" =>    array("duchier", "kornstaedt", "schulte", "smolka"),
            "affiliation" => "SU",
	    "abstract" => <<<EOA
<p>	     
	    We present a higher-order module discipline with
	       separate compilation and concurrent dynamic linking.
	       Based on first-order modules one can program security
	       policies for systems that link modules from untrusted
  locations (e.g., Java).  We introduce a pickling
  operation that writes persistent clones of volatile,
  possibly higher-order data structures on the file
  system.  Our pickling operation respects lexical
  binding.  Our module discipline is based on functors,
  which are annotated functions that are applied to
  modules and return modules.  Pickled computed
  functors can be used interchangeably with compiled
  functors.  In contrast to compiled functors, pickled
  computed functors can carry computed data structures
  with them, which has significant practical
		 applications.
</p>
EOA
	    ),
      
      "MehlSchulteSmolka:DRAFT:1998" =>
      array("type" =>      "draft",
	    "title" =>     "Futures and By-need Synchronization",
	    "year" =>      1998,
	    "author" =>    array("mehl", "schulte", "smolka"),
            "affiliation" => "SU",
	    "abstract" =>  <<<EOA
<p>
We propose a conservative extension of Oz that adds futures and
by-need synchronization. Futures are read-only views of logic
variables that make it possible to statically limit the scope in
which a variable can be constrained. For instance, one can
express with futures safe streams that cannot be assigned by
their readers. By-need synchronization makes it possible to
synchronize a thread on the event that a thread blocks on a
future. It is used to express dynamic linking and lazy functions.
</p>
EOA
	    ),
      
      "HaridiVanRoyEa:NGC:1998" => 
      array("type" =>      "article",
	    "author" =>    array("haridi", "vanroy", "brand", "schulte"),
	    "title" =>     "Programming Languages for Distributed Applications",
	    "journal" =>   "New Generation Computing",
	    "publisher" => "Omsha",
	    "year" =>      1998,
	    "volume" =>    16,
	    "number" =>    3,
	    "pages" =>     array(223,261),
            "affiliation" => "SU",
	    "abstract" => <<<EOA
<p>
Much progress has been made in distributed 
	       computing in the areas of distribution structure, 
	       open computing, fault tolerance, and 
	       security. Yet, writing distributed applications 
	       remains difficult because the programmer has to 
	       manage models of these areas explicitly. A major 
	       challenge is to integrate the four models into a 
	       coherent development platform. Such a platform 
	       should make it possible to cleanly separate an 
	       application's functionality from the other four 
	       concerns.  Concurrent constraint programming, an 
	       evolution of concurrent logic programming, has 
	       both the expressiveness and the formal foundation 
	       needed to attempt this integration. As a first 
	       step, we have designed and built a platform that 
	       separates an application's functionality from its 
	       distribution structure. We have prototyped 
	       several collaborative tools with this platform, 
	       including a shared graphic editor whose design is 
	       presented in detail. The platform efficiently 
	       implements Distributed Oz, which extends the Oz 
	       language with constructs to express the 
	       distribution structure and with basic primitives 
	       for open computing, failure detection and 
	       handling, and resource control. Oz appears to the 
	       programmer as a concurrent object-oriented 
	       language with dataflow synchronization. Oz is 
	       based on a higher-order, state-aware, concurrent 
	       constraint computation model.
</p>
EOA
	    ),

      "Schulte:CP:1997" =>
      array("type" =>      "conference",
	    "author" =>    array("schulte"),
	    "title" =>     "Programming Constraint Inference Engines",
	    "editor" =>    array("Gert Smolka"),
	    "booktitle" => "Proceedings of the Third International Conference on Principles and Practice of Constraint Programming",
	    "year" =>      1997,
	    "address" =>   "Schloß Hagenberg, Austria",
	    "month" =>     "OCT",
	    "publisher" => $SPR,
	    "series" =>    $LNCS,
	    "volume" =>    1330,
	    "pages" =>     array(519,533),
            "copyright" =>   $LNCS_COPY,
            "affiliation" => "DFKI",
	    "abstract" => <<<EOA
<p>
Existing constraint programming systems offer a 
	       fixed set of inference engines implementing search 
	       strategies such as single, all, and best solution 
	       search. This is unfortunate, since new engines 
	       cannot be integrated by the user.  The paper 
	       presents first-class computation spaces as 
	       abstractions with which the user can program 
	       inference engines at a high level.  Using 
	       computation spaces, the paper covers several 
	       inference engines ranging from standard search 
	       strategies to techniques new to constraint 
	       programming, including limited discrepancy search, 
	       visual search, and saturation. Saturation is an 
	       inference method for tautology-checking used in 
	       industrial practice.  Computation spaces have 
	       shown their practicability in the constraint 
	       programming system Oz.
</p>
EOA
	    ),

      "Schulte:ICLP:1997" =>
      array("type" =>      "conference",
	    "author" =>    array("schulte"),
	    "title" =>     "Oz Explorer: A Visual Constraint Programming Tool",
	    "editor" =>    array("Lee Naish"),
	    "booktitle" => "Proceedings of the Fourteenth International Conference on Logic Programming",
	    "year" =>      1997,
	    "address" =>   "Leuven, Belgium",
	    "month" =>     "JUL",
	    "publisher" => $MIT,
	    "pages" =>     array(286,300),
            "affiliation" => "DFKI",
	    "abstract" => <<<EOA
<p>
This paper describes the Oz Explorer and its 
	       implementation. The Explorer is a visual 
	       constraint programming tool intended to support 
	       the development of constraint programs.  It uses 
	       the search tree of a constraint problem as its 
	       central metaphor. Exploration and visualization of 
	       the search tree are user-driven and interactive. 
	       The constraints of any node in the tree are 
	       available first-class: predefined or user-defined 
	       procedures can be used to display or analyze 
	       them. The Explorer is a fast and memory efficient 
	       tool intended for the development of real-world 
	       constraint programs.
</p>
<p>	     
The Explorer is implemented in Oz using 
	       first-class computation spaces.  There is no fixed 
	       search strategy in Oz. Instead, first-class 
	       computation spaces allow to program search 
	       engines. The Explorer is one particular example of 
	       a user-guided search engine. The use of 
	       recomputation to trade space for time makes it 
	       possible to solve large real-world problems, which 
	       would use too much memory otherwise.
</p>
EOA
	    ),

      "Schulte:WOZ:1995" =>
      array("type" =>      "workshop",
	    "author" =>    array("schulte"),
	    "title" =>     "Solver - An {Oz} Search Debugger",
	    "booktitle" => "WOz'95, International Workshop on Oz Programming",
	    "year" =>      1995,
	    "address" =>   "Institut Dalle Molle d'Intelligence Artificielle Perceptive, Martigny, Switzerland",
	    "month" =>     "NOV",
            "affiliation" => "DFKI",
	    "abstract" => <<<EOA
<p>This paper shows the Oz Solver, a tool designed to support the development of constraint programs.</p>
<p>
The Solver allows the user to interactively solve 
		a constraint problem. As the problem's search tree 
		is explored the Solver incrementally draws its 
		graphical presentation. The user has access to the 
		computation state at any node in the tree.
</p>
<p>
Although search is controlled interactively by the 
		user, implementing the Solver does not require any 
		other primitives than those provided by Oz.
</p>
<p>
It is planned to include the Oz Solver in the next 
		release of the DFKI Oz system.
</p>
EOA
          ),

"MehlScheidhauerSchulte:PLILP:1995" =>
    array("type" =>      "conference",
	  "author" =>    array("mehl","scheidhr","schulte"),
	  "title" =>     "An Abstract Machine for {Oz}",
	  "editor" =>    array("Manuel Hermenegildo","S. Doaitse Swierstra"),
	  "booktitle" => "Programming Languages, Implementations, Logics and Programs, Seventh International Symposium, PLILP'95",
	  "year" =>      1995,
	  "series" =>    $LNCS,
	  "volume" =>    982,
	  "address" =>   "Utrecht, The Netherlands",
	  "publisher" => $SPR,
 	  "copyright" =>   $LNCS_COPY,
	  "pages" =>     array(151,168),
          "affiliation" => "DFKI",
	  "abstract" => <<<EOA
<p>
	     Oz is a concurrent constraint language providing 
	       for first-class procedures, concurrent objects, 
	       and encapsulated search. DFKI Oz is an interactive 
	       implementation of Oz competitive in performance 
	       with commercial Prolog and Lisp systems.  This 
	       paper describes AMOZ, the abstract machine 
	       underlying DFKI Oz. AMOZ implements rational tree 
	       constraints, first-class procedures, local 
	       computation spaces for deep guards, and preemptive 
	       and fair threads.
</p>
EOA
          ),

"SchulteSmolka:ILPS:1994" =>
    array("type" =>      "conference",
	  "author" =>    array("schulte", "smolka"),
	  "title" =>     "Encapsulated Search in Higher-order Concurrent Constraint Programming",
	  "editor" =>    array("Maurice Bruynooghe"),
	  "booktitle" => "Logic Programming: Proceedings of the 1994 International Symposium",
	  "year" =>      1994,
	  "address" =>   "Ithaca, NY, USA",
	  "pages" =>     array(505,520),
	  "month" =>     "NOV",
	  "publisher" => $MIT,
          "affiliation" => "DFKI",
	  "abstract" => <<<EOA
<p>
	     The paper presents an extension of the concurrent 
	       constraint model providing for higher-order 
	       programming, deep guards, and encapsulated search. 
	       The paper focuses on a higher-order combinator 
	       providing for encapsulated search.  The search 
	       combinator spawns a local computation space and 
	       resolves remaining choices by returning the 
	       alternatives as first-class citizens.  The search 
	       combinator allows to program different search 
	       strategies, including depth-first, indeterministic 
	       one solution, demand-driven multiple solution, all 
	       solutions, and best solution (branch and bound) 
	       search.  The described computation model is 
	       realized in Oz, a programming language and system 
	       under development at DFKI.
</p>
EOA
          ),
	  
"SchulteSmolkaWuertz:PPCP:1994" =>
    array("type" =>      "workshop",
	  "author" =>    array("schulte", "smolka", "wuertz"),
	  "title" =>     "Encapsulated Search and Constraint Programming in {Oz}",
	  "editor" =>    array("Alan H. Borning"),
	  "booktitle" => "Second International Workshop on Principles and Practice of Constraint Programming",
	  "year" =>      1994,
	  "month" =>     "MAY",
	  "publisher" => $SPR,
	  "series" =>    $LNCS,
          "copyright" =>   $LNCS_COPY,
	  "volume" =>    874,
	  "pages" =>     array(134,150),
	  "address" =>   "Orcas Island, WA, USA",
          "affiliation" => "DFKI",
	  "abstract" => <<<EOA
<p>
	     Oz is an attempt to create a high-level concurrent 
	       programming language providing the problem solving 
	       capabilities of logic programming (i.e., 
	       constraints and search).  Its computation model 
	       can be seen as a rather radical extension of the 
	       concurrent constraint model providing for 
	       higher-order programming, deep guards, state, and 
	       encapsulated search.  This paper focuses on the 
	       most recent extension, a higher-order combinator 
	       providing for encapsulated search.  The search 
	       combinator spawns a local computation space and 
	       resolves remaining choices by returning the 
	       alternatives as first-class citizens.  The search 
	       combinator allows to program different search 
	       strategies, including depth-first, indeterministic 
	       one solution, demand-driven multiple solution, all 
	       solutions, and best solution (branch and bound) 
	       search.  The paper also discusses the semantics of 
	       integer and finite domain constraints in a deep 
	       guard computation model.
</p>
EOA
          ),

      "Schulte:Master:1992" =>
      array("type" =>        "masterthesis",
	    "title" =>       "Entwurf und Implementierung eines übersetzenden
Systems für das intuitionistische logische Programmieren basierend auf
der Warren Abstract Machine",
	    "author" =>      array("schulte"),
	    "school" =>      "Institut für Logik, Komplexität und Deduktionssysteme, Universität Karlsruhe (TH)",
	    "typetype" =>    "Diploma Thesis",
	    "address" =>     "Karlsruhe, Germany",
	    "year" =>        1992,
  	    "month" =>       "JUL",
            "note" =>        "In German",
	    "abstract" =>    <<<EOA
<p>
Das Hornklauselfragment der Prädikatenlogik, das bisher hauptsächlich
als Grundlage für das logische Programmieren dient, insbesondere für die
Programmiersprache PROLOG, ist in seiner Ausdrucksmächtigkeit sehr
eingeschränkt. In den letzten Jahren sind viele Erweiterungen der
Hornklausellogik untersucht worden. Eine Erweiterung, die durch zusätzliche
Typen von Formeln und entsprechende Ableitungsregeln diese
Einschränkungen teilweise aufhebt, ist das <i>intuitionistische
logische Programmieren</i>.
</p>
<p>
Die theoretischen Grundlagen dieser Erweiterung sind in der Literatur
schon umfangreich untersucht worden. Im Gegensatz dazu ist der praktische
Aspekt dieser Erweiterung noch weitgehend unberücksichtigt geblieben.
Diese Arbeit beschäftigt sich mit der Entwicklung, Implementierung und
Untersuchung eines kompletten und praktikablen Systems für das intuitionistische logische
Programmieren.
</p>
<p>
Einleitend werden die Konzepte, die diese Erweiterung ausmachen,
vorgestellt,  und die Sprache, ein erweiterter Unifikationsalgorithmus und
die zugehörige prozedurale Semantik definiert. 
</p>
<p>
Dieses liefert den Ausgangspunkt für die praktische Umsetzung. 
Es wird eine Erweiterung der "Warren Abstract Machine" (WAM) entworfen,
deren Instruktionssatz als Zielsprache für die übersetzung
intuitionistischer logischer Programme dient. Bei dem Entwurf wird
insbesondere auf die Möglichkeit zur Integration anderer Erweiterungen des
logischen Programmierens, die in ihrer Realisierung auch auf die WAM
aufsetzen, geachtet.
</p>
<p>
Basierend auf dem KA--PROLOG System, wird ein komplettes System für das
intuitionistische logische Programmieren realisiert. Dieses System
umfaßt die vorher entworfene Maschine, den zugehörigen Übersetzer und
weitere Komponenten, wie zum Beispiel einen Debugger und ein
Modulkonzept. 
</p>
<p>
Die Untersuchung der Praktikabilität hinsichtlich der effizienten
Unterstützung der Paradigmen des intuitionistischen logischen
Programmierens durch Laufzeitmessungen und Untersuchung der gemessenen
Werte bildet die Grundlage für die Beurteilung und Diskussion 
des realisierten Systems. Die Diskussion berücksichtigt neben dem Vergleich
des erhaltenen mit einem bereits existierenden System auch Schwächen
und Erweiterungsmöglichkeiten der entworfenen und realisierten
Systemkomponenten. Ein Ausblick auf weitere Möglichkeiten schließt die
Arbeit ab.
</p>
<p>
EOA
	    ),

);


?>